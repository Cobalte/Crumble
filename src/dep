final static int chunkWidth = 4;
	final static int lenX = chunkWidth * 16;
	final static int lenZ = chunkWidth * 16;
	final static int lenY = 60;
	
	private static Material[][][] mats;
	
	private static void initLocale() {
		
		mats = new Material[lenX][lenY][lenZ];
		
		// init east/west road
		for (int x = 0; x < lenX; x++) {
			for (int z = 0; z <= 3; z++) {
				mats[x][0][z] = Material.GRAVEL;
			}
		}
		
		// init north/south road
		for (int x = 0; x <= 3; x++) {
			for (int z = 0; z < lenZ; z++) {
				mats[x][0][z] = Material.GRAVEL;
			}
		}
		
		// init structures
		initStructure(5, 0, 5);
		//initStructure(35, 0, 5);
		//initStructure(5, 0, 35);
		//initStructure(5, 0, 35);
		
	}
	
	private static void initStructure(int locX, int locY, int locZ) {
		
		initWall(locX, locY, locZ, 14, 3, 0, Material.SMOOTH_BRICK); // north wall
		initWall(locX, locY, locZ, 0, 3, 14, Material.SMOOTH_BRICK); // west wall
		initWall(locX + 14, locY, locZ, 0, 3, 14, Material.SMOOTH_BRICK); // east wall
		initWall(locX, locY, locZ + 14, 14, 3, 0, Material.SMOOTH_BRICK); // south wall
		
	}
	
	private static void initWall(int locX, int locY, int locZ, int width, int height, int length, Material mat) {
		for (int x = locX; x <= locX + width; x++) {
			for (int z = locZ; z <= locZ + length; z++) {
				for (int y = locY; y <= locY + height; y++) {
					mats[x][y][z] = mat;
				}
			}
		}
	}
	
	public Material[][][] getMaterials(int offsetX, int offsetZ) {
		Material[][][] result = new Material[16][lenY][16];
		
		for (int x = 0; x < 16; x++) {
			for (int z = 0; z < 16; z++) {
				for (int y = 0; y < lenY; y++) {
					
					int resultX = offsetX * 16 + x;
					int resultZ = offsetZ * 16 + z;

					//invalid location check
					if (resultX > 0 && resultX < 16 && resultZ > 0 && resultZ < 16) {
						result[x][y][z] = mats[resultX][y][resultZ];
					}
					
				}
			}
		}
		
		return result;
	}
	
	public CrumbleLocalePopulator() {
		initLocale();
	}
	
-----------------------------------------

// determine relative offset
		int relX = chunk.getX();
		int relZ = chunk.getZ();
		while (relX < 0) relX += 4;
		while (relZ < 0) relZ += 4;
		
		// get the materials for this chunk
		Material[][][] mats = locale.getMaterials(relX % 4, relZ % 4);
		
		// copy materials into chunk
		for (int x = 0; x < 16; x++) {
			for (int z = 0; z < 16; z++) {
				for (int y = 0; y < mats[0].length; y++) {
					
					Material thisMat = mats[x][y][z];
					if (thisMat != null) {
						int absX = (chunk.getX() << 4) + x;
						int absZ = (chunk.getZ() << 4) + z;
						crumble.getBlockAt(absX, y + GROUND_LEVEL, absZ).setType(mats[x][y][z]);
					}
					
				}
			}
		}
		
		// make sign
        Block signBlock = crumble.getBlockAt((chunk.getX() << 4), GROUND_LEVEL + 1, (chunk.getZ() << 4));
        signBlock.setType(Material.SIGN_POST);        
        BlockState state = signBlock.getState();
        Sign sign = (Sign)state;
        org.bukkit.material.Sign data = (org.bukkit.material.Sign)state.getData();
        data.setFacingDirection(BlockFace.NORTH);
        sign.setLine(0, "chunk x = " + String.valueOf(chunk.getX()));
        sign.setLine(1, "chunk z = " + String.valueOf(chunk.getZ()));
        sign.setLine(2, "rel x % 4 = " + String.valueOf(relX % 4));
        sign.setLine(3, "rel z % 4 = " + String.valueOf(relZ % 4));
        sign.update(true);